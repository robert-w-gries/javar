THINGS THAT NEED TO BE ADDRESSED
--------------------------------

In Translate, basically everything. Start with program and get a basic testcase to work and build
up from there.

The symbol table will need to be touched to add temp vars to it.

All the things.




------------------------------------------LAST PROJECT ?
- Implement symbol table
    - Maps identifiers (strings) to Types
    - should implement the methods the Brylow told us to make
        - the symbol table should have an internal HashMap<String, Type>
        - void put(String symbol, Type type) // puts a symbol in the table with a corresponding type
        - Type get(String symbol) // retrieve a type for an existing symbol
        - void beginScope() // indicate to the table that we are beginning a new scope
        - void endScope() // indicate to the table that we are ending the current scope
        - READ CHAPTER 5, IT EXPLAINS ALL OF THIS
    - There will be 2 symbol tables, 1 that will be used in the passes that assemble classes,
      and 1 that will be used in the last pass that checks the inside of methods
- PrintVisitor
    - copy prints for Absyn classes from Absyn.PrintVisitor to new PrintVisitor
    - add logic for printing Types after every declaration in the AST
- TypeChecker
    - 1st pass: Put classes in symbol table
        - Go through the AST, put classes in the symbol table, initialize those classes
          with empty records and null parent and instance
        - ERRORS:
            - ERROR duplicate class (class already inside symbol table)
    - 2nd pass: Add class parents, populate method and field records
        - Go through the AST, grabbing parent types, field types, and method parameter and return types
        - Set each CLASS's field and method records, and set its parent
        - ERRORS:
            - ERROR cannot resolve parent class sigma (found an "extends" with a parent class that doesn't exist)
            - ERROR cannot resolve class sigma (found a type for a field or method that doesn't exist)
            - ERROR x is already defined in y (found multiple fields or methods in the same class with the same name)
    - 3rd pass: Cyclic inheritance check
        - Go through the symbol table and determine if there is cyclic inheritance
        - Should have an error for all classes in the cycle
        - ERRORS:
            - ERROR cyclic inheritance involving sigma (found an inheritance cycle involving this class)
    - 4th pass: Create instances for each class
        - Recursively go up the parent chain, adding each parent's fields and methods to the class's instance
        - ERRORS:
            - ERROR incompatible method override: x in class sigma (a method was found with the same name as a method
              in the parent, but different return type and argument types and number)
    - 5th pass: Method scope check
        - Go through each method and use the second symbol table to record each assignment, expression, and statement
          for valid type usage
        - ERRORS:
            - ERROR cannot resolve symbol x (found a symbol used that was not found in the table)
            - ERROR cannot resolve method foo (found a method used that was not found in the table)
            - ERROR incompatible types: sigma required, but tau found (unable to coerce tau to a sigma)
            - ERROR incompatible types: array required, but sigma found (found an assignment to an array that wasn't)
            - ERROR operator o cannot be applied to sigma (unary operator on an invalid type)
            - ERROR operator o cannot be applied to sigma, tau (binary operator on two invalid types)
            - ERROR target not object, type sigma (method or field called on a type that wasn't an object)
            - ERROR mismatch in number of arguments (method called with incorrect number of arguments)


HOW TO RUN BRYLOW'S IMPLEMENTATION WITH THE PARSER BEFORE IT
------------------------------------------------------------

./parser <file> | ./checker -

# Explanation:
# run the parser for a file, and pipe the output into stdin, then run the checker with the '-' flag, indicating that
# it should read from stdin instead of a file


QUESTIONS FOR BRYLOW
--------------------

- how should we call coerceTo() when checking the return type vs. the type of the expression returned?
- are we supporting equality for non int or boolean types?
- can the calls to Xinu be handled explicitly in the parser or should they be done in the checker?